#!/usr/bin/env python

import os, sys, time, glob
from subprocess import *
from itertools import *
from PIL import Image
from raster_utils import *
import emc

P, Q = map(lambda x: float(x), sys.argv[1:])
#print 'P=%g Q=%g' % (P, Q)

ini = emc.ini('2x_Laser.ini')
emc.nmlfile = ini.find('EMC', 'NML_FILE')

axis = ini.find('RASTER', 'AXIS')
if axis is None:
    axis = 0

stat = emc.stat()

stat.poll()
origin = stat.origin[axis]

if stat.current_line < 0:
    print 'cannot execute M101 from MDI'
    sys.exit(2)

# When using O- call the filename will be the XXX.ngc file :(
#image_name = get_comment(stat.file, stat.current_line)
#dirname = os.path.dirname(stat.file)
#image_name = os.path.normpath(os.path.join(dirname, image_name))
images = glob.glob('*-%u.*' % int(P))
# XXX BETTER ERROR HANDLING
image_name = images[0]
print 'image = %s' % image_name

if os.fork():
    # parent must wait until child is ready, then exit
    #...
    time.sleep(1)
    sys.exit(0)
else:
    # XXX not sure if necessary
    os.setsid()

    streamer = Popen(['halstreamer'], stdin=PIPE)
    stream = streamer.stdin

    image = Image.open(image_name)

    # wait for M145 to send us the image info
    X, Y = recv_params()
    W, H = recv_params()
    XSCANGAP, YSCANGAP = recv_params()

    # program units are 1:inch, 2:mm, while linear_units are 0:inch, 1:mm
    if stat.program_units == 1 and stat.linear_units == 1:
	scale = 25.4
    elif stat.program_units == 2 and stat.linear_units == 0:
	scale = 1/25.4
    else:
	scale = 1
    X *= scale
    Y *= scale
    W *= scale
    H *= scale
    XSCANGAP *= scale
    YSCANGAP *= scale

    x_mmpd = XSCANGAP
    y_mmpd = YSCANGAP
    origin += X

    pix_w = int(W / x_mmpd)
    pix_h = int(H / y_mmpd)
    W = pix_w * x_mmpd
    H = pix_h * y_mmpd

    reverse_fudge = 0.0
    #reverse_fudge = 0.339

    print 'rescaling to %u,%u' % (pix_w, pix_h)
    #XXX
    image = image.resize((pix_w, pix_h), Image.BICUBIC).convert('1')
    #image = image.resize((pix_w, pix_h), Image.NEAREST).convert('1')
    image.save('actual.png')
    # XXX possibly rotate based on axis

    pix = list(image.getdata())

    for y in xrange(0,pix_h):
	forward = (y & 1) == 0

	# laser is off until cued for this line:
	if forward:
	    stream.write('0 1 %0.3f\n' % (origin))
	else:
	    stream.write('0 0 %0.3f\n' % (origin + W + x_mmpd))

	if False:
	    if forward == (y > pix_h / 2):
		continue

	row = pix[y * pix_w:(y + 1) * pix_w]
	grouped = groupby(row)
	groups = map(lambda (v,run): (v, len(list(run))), groupby(row))
	if forward:
	    x = 0
	else:
	    groups.reverse()
	    x = pix_w
	for v, run in groups:
	    if (v <= 127):
		# off until we hit start / on until end
		if forward:
		    stream.write('0 0 %0.3f\n' % (origin + x * x_mmpd))
		    stream.write('1 0 %0.3f\n' % (origin + (x + run) * x_mmpd))
		else:
		    stream.write('0 1 %0.3f\n' % (origin + x * x_mmpd + reverse_fudge))
		    stream.write('1 1 %0.3f\n' % (origin + (x - run) * x_mmpd + reverse_fudge))
	    if forward:
		x += run
	    else:
		x -= run

    stream.close()
    streamer.wait()

    print 'DONE!'
